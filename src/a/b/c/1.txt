/******************************************************************************
* File:             main.c
*
* Author:           qrsforever
* Created:          10/28/22
* Description:
*****************************************************************************/

#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/stat.h>
#include <sys/wait.h>

#define HH_FIFO_PATH "/run/vsftpd.fifo"
#define MSG_LEN 128

static int g_msg_writer = -1;

void catch_signal(int sig)
{
    printf("catch sig: %d, msg writer: %d", sig, g_msg_writer);
    if (g_msg_writer > 0) {
        char buff[MSG_LEN] = {"quit"};
        write(g_msg_writer, buff, MSG_LEN);
    }
    sleep(2);
    exit(0);
}

void *handle_message(void *arg)
{
    char* image_file_path = (char*)arg;
    if (image_file_path != NULL) {
        printf("handle_message: %s\n", image_file_path);
        free(image_file_path);
    }
    return NULL;
}


int main(void)
{
    printf("Start\n");
    int ret = access(HH_FIFO_PATH, F_OK);
    if (-1 == ret) {
        ret = mkfifo(HH_FIFO_PATH, 0664);
        if (-1 == ret) {
            perror("mkfifo");
            exit(-1);
        }
    }

    int child_pid = fork();
    if (child_pid > 0) {
        printf("parent process start...\n");
        signal(SIGINT, catch_signal);
        signal(SIGTERM, catch_signal);

        int fw = open(HH_FIFO_PATH, O_WRONLY);
        if (-1 == fw) {
            perror("open");
            exit(-1);
        }
        g_msg_writer = fw;
		int status=0, rc=0;
		rc = waitpid(child_pid, &status, 0);
		if (WIFEXITED(status)) {
			printf("parent %u get child %u exit code:%d\n", getpid(), rc, WEXITSTATUS(status));
        }
    } else if (child_pid == 0) {
        printf("child process start...\n");
        int fr = open(HH_FIFO_PATH, O_RDONLY);
        if (-1 == fr) {
            perror("open");
            exit(-1);
        }
        while (1) {
            char buff[MSG_LEN] = {0};
            int len = read(fr, buff, MSG_LEN);
            if (len == 0) {
                perror("read");
                break;
            }
            printf("recv: %s\n", buff);
            if (strcmp(buff, "quit") == 0)
                break;
            char* msg = (char*)malloc(MSG_LEN);
            memcpy(msg, buff, MSG_LEN);
            pthread_t thread;
            int ret = pthread_create(&thread, NULL, handle_message, (void*)msg);
            if (ret != 0) {
                perror("pthread_create");
                continue;
            }
            pthread_detach(thread);
        }
        close(fr);
    } else {
        perror("fork");
        exit(-1);
    }
    return 0;
}
